// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: belifeline/v1/main.proto

package mainv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/halcyon-org/kizuna/gen/belifeline/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// HealthServiceName is the fully-qualified name of the HealthService service.
	HealthServiceName = "belifeline.v1.HealthService"
	// AdminServiceName is the fully-qualified name of the AdminService service.
	AdminServiceName = "belifeline.v1.AdminService"
	// ProviderServiceName is the fully-qualified name of the ProviderService service.
	ProviderServiceName = "belifeline.v1.ProviderService"
	// ExternalInformationServiceName is the fully-qualified name of the ExternalInformationService
	// service.
	ExternalInformationServiceName = "belifeline.v1.ExternalInformationService"
	// KoyoServiceName is the fully-qualified name of the KoyoService service.
	KoyoServiceName = "belifeline.v1.KoyoService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// HealthServiceCheckProcedure is the fully-qualified name of the HealthService's Check RPC.
	HealthServiceCheckProcedure = "/belifeline.v1.HealthService/Check"
	// HealthServiceWatchProcedure is the fully-qualified name of the HealthService's Watch RPC.
	HealthServiceWatchProcedure = "/belifeline.v1.HealthService/Watch"
	// AdminServiceClientSetProcedure is the fully-qualified name of the AdminService's ClientSet RPC.
	AdminServiceClientSetProcedure = "/belifeline.v1.AdminService/ClientSet"
	// AdminServiceClientListProcedure is the fully-qualified name of the AdminService's ClientList RPC.
	AdminServiceClientListProcedure = "/belifeline.v1.AdminService/ClientList"
	// AdminServiceClientDeleteProcedure is the fully-qualified name of the AdminService's ClientDelete
	// RPC.
	AdminServiceClientDeleteProcedure = "/belifeline.v1.AdminService/ClientDelete"
	// AdminServiceClientRevokeProcedure is the fully-qualified name of the AdminService's ClientRevoke
	// RPC.
	AdminServiceClientRevokeProcedure = "/belifeline.v1.AdminService/ClientRevoke"
	// AdminServiceExternalInformationSetProcedure is the fully-qualified name of the AdminService's
	// ExternalInformationSet RPC.
	AdminServiceExternalInformationSetProcedure = "/belifeline.v1.AdminService/ExternalInformationSet"
	// AdminServiceExternalInformationDeleteProcedure is the fully-qualified name of the AdminService's
	// ExternalInformationDelete RPC.
	AdminServiceExternalInformationDeleteProcedure = "/belifeline.v1.AdminService/ExternalInformationDelete"
	// AdminServiceKoyoCreateProcedure is the fully-qualified name of the AdminService's KoyoCreate RPC.
	AdminServiceKoyoCreateProcedure = "/belifeline.v1.AdminService/KoyoCreate"
	// AdminServiceKoyoDeleteProcedure is the fully-qualified name of the AdminService's KoyoDelete RPC.
	AdminServiceKoyoDeleteProcedure = "/belifeline.v1.AdminService/KoyoDelete"
	// AdminServiceKoyoAPIRevokeProcedure is the fully-qualified name of the AdminService's
	// KoyoAPIRevoke RPC.
	AdminServiceKoyoAPIRevokeProcedure = "/belifeline.v1.AdminService/KoyoAPIRevoke"
	// ProviderServiceExternalInformationListProcedure is the fully-qualified name of the
	// ProviderService's ExternalInformationList RPC.
	ProviderServiceExternalInformationListProcedure = "/belifeline.v1.ProviderService/ExternalInformationList"
	// ProviderServiceKoyoListProcedure is the fully-qualified name of the ProviderService's KoyoList
	// RPC.
	ProviderServiceKoyoListProcedure = "/belifeline.v1.ProviderService/KoyoList"
	// ProviderServiceExternalInformationGetProcedure is the fully-qualified name of the
	// ProviderService's ExternalInformationGet RPC.
	ProviderServiceExternalInformationGetProcedure = "/belifeline.v1.ProviderService/ExternalInformationGet"
	// ProviderServiceKoyoDataGetProcedure is the fully-qualified name of the ProviderService's
	// KoyoDataGet RPC.
	ProviderServiceKoyoDataGetProcedure = "/belifeline.v1.ProviderService/KoyoDataGet"
	// ExternalInformationServiceExternalInformationUpdateNotificationProcedure is the fully-qualified
	// name of the ExternalInformationService's ExternalInformationUpdateNotification RPC.
	ExternalInformationServiceExternalInformationUpdateNotificationProcedure = "/belifeline.v1.ExternalInformationService/ExternalInformationUpdateNotification"
	// KoyoServiceKoyoUpdateProcedure is the fully-qualified name of the KoyoService's KoyoUpdate RPC.
	KoyoServiceKoyoUpdateProcedure = "/belifeline.v1.KoyoService/KoyoUpdate"
	// KoyoServiceKoyoDataAddProcedure is the fully-qualified name of the KoyoService's KoyoDataAdd RPC.
	KoyoServiceKoyoDataAddProcedure = "/belifeline.v1.KoyoService/KoyoDataAdd"
)

// These variables are the protoreflect.Descriptor objects for the RPCs defined in this package.
var (
	healthServiceServiceDescriptor                                                  = v1.File_belifeline_v1_main_proto.Services().ByName("HealthService")
	healthServiceCheckMethodDescriptor                                              = healthServiceServiceDescriptor.Methods().ByName("Check")
	healthServiceWatchMethodDescriptor                                              = healthServiceServiceDescriptor.Methods().ByName("Watch")
	adminServiceServiceDescriptor                                                   = v1.File_belifeline_v1_main_proto.Services().ByName("AdminService")
	adminServiceClientSetMethodDescriptor                                           = adminServiceServiceDescriptor.Methods().ByName("ClientSet")
	adminServiceClientListMethodDescriptor                                          = adminServiceServiceDescriptor.Methods().ByName("ClientList")
	adminServiceClientDeleteMethodDescriptor                                        = adminServiceServiceDescriptor.Methods().ByName("ClientDelete")
	adminServiceClientRevokeMethodDescriptor                                        = adminServiceServiceDescriptor.Methods().ByName("ClientRevoke")
	adminServiceExternalInformationSetMethodDescriptor                              = adminServiceServiceDescriptor.Methods().ByName("ExternalInformationSet")
	adminServiceExternalInformationDeleteMethodDescriptor                           = adminServiceServiceDescriptor.Methods().ByName("ExternalInformationDelete")
	adminServiceKoyoCreateMethodDescriptor                                          = adminServiceServiceDescriptor.Methods().ByName("KoyoCreate")
	adminServiceKoyoDeleteMethodDescriptor                                          = adminServiceServiceDescriptor.Methods().ByName("KoyoDelete")
	adminServiceKoyoAPIRevokeMethodDescriptor                                       = adminServiceServiceDescriptor.Methods().ByName("KoyoAPIRevoke")
	providerServiceServiceDescriptor                                                = v1.File_belifeline_v1_main_proto.Services().ByName("ProviderService")
	providerServiceExternalInformationListMethodDescriptor                          = providerServiceServiceDescriptor.Methods().ByName("ExternalInformationList")
	providerServiceKoyoListMethodDescriptor                                         = providerServiceServiceDescriptor.Methods().ByName("KoyoList")
	providerServiceExternalInformationGetMethodDescriptor                           = providerServiceServiceDescriptor.Methods().ByName("ExternalInformationGet")
	providerServiceKoyoDataGetMethodDescriptor                                      = providerServiceServiceDescriptor.Methods().ByName("KoyoDataGet")
	externalInformationServiceServiceDescriptor                                     = v1.File_belifeline_v1_main_proto.Services().ByName("ExternalInformationService")
	externalInformationServiceExternalInformationUpdateNotificationMethodDescriptor = externalInformationServiceServiceDescriptor.Methods().ByName("ExternalInformationUpdateNotification")
	koyoServiceServiceDescriptor                                                    = v1.File_belifeline_v1_main_proto.Services().ByName("KoyoService")
	koyoServiceKoyoUpdateMethodDescriptor                                           = koyoServiceServiceDescriptor.Methods().ByName("KoyoUpdate")
	koyoServiceKoyoDataAddMethodDescriptor                                          = koyoServiceServiceDescriptor.Methods().ByName("KoyoDataAdd")
)

// HealthServiceClient is a client for the belifeline.v1.HealthService service.
type HealthServiceClient interface {
	// Check the health of the service
	Check(context.Context, *connect.Request[v1.CheckRequest]) (*connect.Response[v1.CheckResponse], error)
	// Watch the health of the service
	Watch(context.Context, *connect.Request[v1.WatchRequest]) (*connect.ServerStreamForClient[v1.WatchResponse], error)
}

// NewHealthServiceClient constructs a client for the belifeline.v1.HealthService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewHealthServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) HealthServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &healthServiceClient{
		check: connect.NewClient[v1.CheckRequest, v1.CheckResponse](
			httpClient,
			baseURL+HealthServiceCheckProcedure,
			connect.WithSchema(healthServiceCheckMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		watch: connect.NewClient[v1.WatchRequest, v1.WatchResponse](
			httpClient,
			baseURL+HealthServiceWatchProcedure,
			connect.WithSchema(healthServiceWatchMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// healthServiceClient implements HealthServiceClient.
type healthServiceClient struct {
	check *connect.Client[v1.CheckRequest, v1.CheckResponse]
	watch *connect.Client[v1.WatchRequest, v1.WatchResponse]
}

// Check calls belifeline.v1.HealthService.Check.
func (c *healthServiceClient) Check(ctx context.Context, req *connect.Request[v1.CheckRequest]) (*connect.Response[v1.CheckResponse], error) {
	return c.check.CallUnary(ctx, req)
}

// Watch calls belifeline.v1.HealthService.Watch.
func (c *healthServiceClient) Watch(ctx context.Context, req *connect.Request[v1.WatchRequest]) (*connect.ServerStreamForClient[v1.WatchResponse], error) {
	return c.watch.CallServerStream(ctx, req)
}

// HealthServiceHandler is an implementation of the belifeline.v1.HealthService service.
type HealthServiceHandler interface {
	// Check the health of the service
	Check(context.Context, *connect.Request[v1.CheckRequest]) (*connect.Response[v1.CheckResponse], error)
	// Watch the health of the service
	Watch(context.Context, *connect.Request[v1.WatchRequest], *connect.ServerStream[v1.WatchResponse]) error
}

// NewHealthServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewHealthServiceHandler(svc HealthServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	healthServiceCheckHandler := connect.NewUnaryHandler(
		HealthServiceCheckProcedure,
		svc.Check,
		connect.WithSchema(healthServiceCheckMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	healthServiceWatchHandler := connect.NewServerStreamHandler(
		HealthServiceWatchProcedure,
		svc.Watch,
		connect.WithSchema(healthServiceWatchMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/belifeline.v1.HealthService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case HealthServiceCheckProcedure:
			healthServiceCheckHandler.ServeHTTP(w, r)
		case HealthServiceWatchProcedure:
			healthServiceWatchHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedHealthServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedHealthServiceHandler struct{}

func (UnimplementedHealthServiceHandler) Check(context.Context, *connect.Request[v1.CheckRequest]) (*connect.Response[v1.CheckResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.HealthService.Check is not implemented"))
}

func (UnimplementedHealthServiceHandler) Watch(context.Context, *connect.Request[v1.WatchRequest], *connect.ServerStream[v1.WatchResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.HealthService.Watch is not implemented"))
}

// AdminServiceClient is a client for the belifeline.v1.AdminService service.
type AdminServiceClient interface {
	// Create or update a client. The client ID is automatically generated and returned
	ClientSet(context.Context, *connect.Request[v1.ClientSetRequest]) (*connect.Response[v1.ClientSetResponse], error)
	// List all clients
	ClientList(context.Context, *connect.Request[v1.ClientListRequest]) (*connect.Response[v1.ClientListResponse], error)
	// Delete a client
	ClientDelete(context.Context, *connect.Request[v1.ClientDeleteRequest]) (*connect.Response[v1.ClientDeleteResponse], error)
	// Revoke and renew the client's API key. The client's API key is automatically generated and returned
	ClientRevoke(context.Context, *connect.Request[v1.ClientRevokeRequest]) (*connect.Response[v1.ClientRevokeResponse], error)
	// Create or update an external information. The external information provider ID is automatically generated and returned
	ExternalInformationSet(context.Context, *connect.Request[v1.ExternalInformationSetRequest]) (*connect.Response[v1.ExternalInformationSetResponse], error)
	// Delete an external information
	ExternalInformationDelete(context.Context, *connect.Request[v1.ExternalInformationDeleteRequest]) (*connect.Response[v1.ExternalInformationDeleteResponse], error)
	// *
	// Create or update a koyo
	// The koyo ID is automatically generated and returned
	KoyoCreate(context.Context, *connect.Request[v1.KoyoCreateRequest]) (*connect.Response[v1.KoyoCreateResponse], error)
	// Delete a koyo
	KoyoDelete(context.Context, *connect.Request[v1.KoyoDeleteRequest]) (*connect.Response[v1.KoyoDeleteResponse], error)
	// Revoke and renew the koyo's API key. The koyo's API key is automatically generated and returned
	KoyoAPIRevoke(context.Context, *connect.Request[v1.KoyoAPIRevokeRequest]) (*connect.Response[v1.KoyoAPIRevokeResponse], error)
}

// NewAdminServiceClient constructs a client for the belifeline.v1.AdminService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewAdminServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) AdminServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &adminServiceClient{
		clientSet: connect.NewClient[v1.ClientSetRequest, v1.ClientSetResponse](
			httpClient,
			baseURL+AdminServiceClientSetProcedure,
			connect.WithSchema(adminServiceClientSetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		clientList: connect.NewClient[v1.ClientListRequest, v1.ClientListResponse](
			httpClient,
			baseURL+AdminServiceClientListProcedure,
			connect.WithSchema(adminServiceClientListMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		clientDelete: connect.NewClient[v1.ClientDeleteRequest, v1.ClientDeleteResponse](
			httpClient,
			baseURL+AdminServiceClientDeleteProcedure,
			connect.WithSchema(adminServiceClientDeleteMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		clientRevoke: connect.NewClient[v1.ClientRevokeRequest, v1.ClientRevokeResponse](
			httpClient,
			baseURL+AdminServiceClientRevokeProcedure,
			connect.WithSchema(adminServiceClientRevokeMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		externalInformationSet: connect.NewClient[v1.ExternalInformationSetRequest, v1.ExternalInformationSetResponse](
			httpClient,
			baseURL+AdminServiceExternalInformationSetProcedure,
			connect.WithSchema(adminServiceExternalInformationSetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		externalInformationDelete: connect.NewClient[v1.ExternalInformationDeleteRequest, v1.ExternalInformationDeleteResponse](
			httpClient,
			baseURL+AdminServiceExternalInformationDeleteProcedure,
			connect.WithSchema(adminServiceExternalInformationDeleteMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		koyoCreate: connect.NewClient[v1.KoyoCreateRequest, v1.KoyoCreateResponse](
			httpClient,
			baseURL+AdminServiceKoyoCreateProcedure,
			connect.WithSchema(adminServiceKoyoCreateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		koyoDelete: connect.NewClient[v1.KoyoDeleteRequest, v1.KoyoDeleteResponse](
			httpClient,
			baseURL+AdminServiceKoyoDeleteProcedure,
			connect.WithSchema(adminServiceKoyoDeleteMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		koyoAPIRevoke: connect.NewClient[v1.KoyoAPIRevokeRequest, v1.KoyoAPIRevokeResponse](
			httpClient,
			baseURL+AdminServiceKoyoAPIRevokeProcedure,
			connect.WithSchema(adminServiceKoyoAPIRevokeMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// adminServiceClient implements AdminServiceClient.
type adminServiceClient struct {
	clientSet                 *connect.Client[v1.ClientSetRequest, v1.ClientSetResponse]
	clientList                *connect.Client[v1.ClientListRequest, v1.ClientListResponse]
	clientDelete              *connect.Client[v1.ClientDeleteRequest, v1.ClientDeleteResponse]
	clientRevoke              *connect.Client[v1.ClientRevokeRequest, v1.ClientRevokeResponse]
	externalInformationSet    *connect.Client[v1.ExternalInformationSetRequest, v1.ExternalInformationSetResponse]
	externalInformationDelete *connect.Client[v1.ExternalInformationDeleteRequest, v1.ExternalInformationDeleteResponse]
	koyoCreate                *connect.Client[v1.KoyoCreateRequest, v1.KoyoCreateResponse]
	koyoDelete                *connect.Client[v1.KoyoDeleteRequest, v1.KoyoDeleteResponse]
	koyoAPIRevoke             *connect.Client[v1.KoyoAPIRevokeRequest, v1.KoyoAPIRevokeResponse]
}

// ClientSet calls belifeline.v1.AdminService.ClientSet.
func (c *adminServiceClient) ClientSet(ctx context.Context, req *connect.Request[v1.ClientSetRequest]) (*connect.Response[v1.ClientSetResponse], error) {
	return c.clientSet.CallUnary(ctx, req)
}

// ClientList calls belifeline.v1.AdminService.ClientList.
func (c *adminServiceClient) ClientList(ctx context.Context, req *connect.Request[v1.ClientListRequest]) (*connect.Response[v1.ClientListResponse], error) {
	return c.clientList.CallUnary(ctx, req)
}

// ClientDelete calls belifeline.v1.AdminService.ClientDelete.
func (c *adminServiceClient) ClientDelete(ctx context.Context, req *connect.Request[v1.ClientDeleteRequest]) (*connect.Response[v1.ClientDeleteResponse], error) {
	return c.clientDelete.CallUnary(ctx, req)
}

// ClientRevoke calls belifeline.v1.AdminService.ClientRevoke.
func (c *adminServiceClient) ClientRevoke(ctx context.Context, req *connect.Request[v1.ClientRevokeRequest]) (*connect.Response[v1.ClientRevokeResponse], error) {
	return c.clientRevoke.CallUnary(ctx, req)
}

// ExternalInformationSet calls belifeline.v1.AdminService.ExternalInformationSet.
func (c *adminServiceClient) ExternalInformationSet(ctx context.Context, req *connect.Request[v1.ExternalInformationSetRequest]) (*connect.Response[v1.ExternalInformationSetResponse], error) {
	return c.externalInformationSet.CallUnary(ctx, req)
}

// ExternalInformationDelete calls belifeline.v1.AdminService.ExternalInformationDelete.
func (c *adminServiceClient) ExternalInformationDelete(ctx context.Context, req *connect.Request[v1.ExternalInformationDeleteRequest]) (*connect.Response[v1.ExternalInformationDeleteResponse], error) {
	return c.externalInformationDelete.CallUnary(ctx, req)
}

// KoyoCreate calls belifeline.v1.AdminService.KoyoCreate.
func (c *adminServiceClient) KoyoCreate(ctx context.Context, req *connect.Request[v1.KoyoCreateRequest]) (*connect.Response[v1.KoyoCreateResponse], error) {
	return c.koyoCreate.CallUnary(ctx, req)
}

// KoyoDelete calls belifeline.v1.AdminService.KoyoDelete.
func (c *adminServiceClient) KoyoDelete(ctx context.Context, req *connect.Request[v1.KoyoDeleteRequest]) (*connect.Response[v1.KoyoDeleteResponse], error) {
	return c.koyoDelete.CallUnary(ctx, req)
}

// KoyoAPIRevoke calls belifeline.v1.AdminService.KoyoAPIRevoke.
func (c *adminServiceClient) KoyoAPIRevoke(ctx context.Context, req *connect.Request[v1.KoyoAPIRevokeRequest]) (*connect.Response[v1.KoyoAPIRevokeResponse], error) {
	return c.koyoAPIRevoke.CallUnary(ctx, req)
}

// AdminServiceHandler is an implementation of the belifeline.v1.AdminService service.
type AdminServiceHandler interface {
	// Create or update a client. The client ID is automatically generated and returned
	ClientSet(context.Context, *connect.Request[v1.ClientSetRequest]) (*connect.Response[v1.ClientSetResponse], error)
	// List all clients
	ClientList(context.Context, *connect.Request[v1.ClientListRequest]) (*connect.Response[v1.ClientListResponse], error)
	// Delete a client
	ClientDelete(context.Context, *connect.Request[v1.ClientDeleteRequest]) (*connect.Response[v1.ClientDeleteResponse], error)
	// Revoke and renew the client's API key. The client's API key is automatically generated and returned
	ClientRevoke(context.Context, *connect.Request[v1.ClientRevokeRequest]) (*connect.Response[v1.ClientRevokeResponse], error)
	// Create or update an external information. The external information provider ID is automatically generated and returned
	ExternalInformationSet(context.Context, *connect.Request[v1.ExternalInformationSetRequest]) (*connect.Response[v1.ExternalInformationSetResponse], error)
	// Delete an external information
	ExternalInformationDelete(context.Context, *connect.Request[v1.ExternalInformationDeleteRequest]) (*connect.Response[v1.ExternalInformationDeleteResponse], error)
	// *
	// Create or update a koyo
	// The koyo ID is automatically generated and returned
	KoyoCreate(context.Context, *connect.Request[v1.KoyoCreateRequest]) (*connect.Response[v1.KoyoCreateResponse], error)
	// Delete a koyo
	KoyoDelete(context.Context, *connect.Request[v1.KoyoDeleteRequest]) (*connect.Response[v1.KoyoDeleteResponse], error)
	// Revoke and renew the koyo's API key. The koyo's API key is automatically generated and returned
	KoyoAPIRevoke(context.Context, *connect.Request[v1.KoyoAPIRevokeRequest]) (*connect.Response[v1.KoyoAPIRevokeResponse], error)
}

// NewAdminServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewAdminServiceHandler(svc AdminServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	adminServiceClientSetHandler := connect.NewUnaryHandler(
		AdminServiceClientSetProcedure,
		svc.ClientSet,
		connect.WithSchema(adminServiceClientSetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	adminServiceClientListHandler := connect.NewUnaryHandler(
		AdminServiceClientListProcedure,
		svc.ClientList,
		connect.WithSchema(adminServiceClientListMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	adminServiceClientDeleteHandler := connect.NewUnaryHandler(
		AdminServiceClientDeleteProcedure,
		svc.ClientDelete,
		connect.WithSchema(adminServiceClientDeleteMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	adminServiceClientRevokeHandler := connect.NewUnaryHandler(
		AdminServiceClientRevokeProcedure,
		svc.ClientRevoke,
		connect.WithSchema(adminServiceClientRevokeMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	adminServiceExternalInformationSetHandler := connect.NewUnaryHandler(
		AdminServiceExternalInformationSetProcedure,
		svc.ExternalInformationSet,
		connect.WithSchema(adminServiceExternalInformationSetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	adminServiceExternalInformationDeleteHandler := connect.NewUnaryHandler(
		AdminServiceExternalInformationDeleteProcedure,
		svc.ExternalInformationDelete,
		connect.WithSchema(adminServiceExternalInformationDeleteMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	adminServiceKoyoCreateHandler := connect.NewUnaryHandler(
		AdminServiceKoyoCreateProcedure,
		svc.KoyoCreate,
		connect.WithSchema(adminServiceKoyoCreateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	adminServiceKoyoDeleteHandler := connect.NewUnaryHandler(
		AdminServiceKoyoDeleteProcedure,
		svc.KoyoDelete,
		connect.WithSchema(adminServiceKoyoDeleteMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	adminServiceKoyoAPIRevokeHandler := connect.NewUnaryHandler(
		AdminServiceKoyoAPIRevokeProcedure,
		svc.KoyoAPIRevoke,
		connect.WithSchema(adminServiceKoyoAPIRevokeMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/belifeline.v1.AdminService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case AdminServiceClientSetProcedure:
			adminServiceClientSetHandler.ServeHTTP(w, r)
		case AdminServiceClientListProcedure:
			adminServiceClientListHandler.ServeHTTP(w, r)
		case AdminServiceClientDeleteProcedure:
			adminServiceClientDeleteHandler.ServeHTTP(w, r)
		case AdminServiceClientRevokeProcedure:
			adminServiceClientRevokeHandler.ServeHTTP(w, r)
		case AdminServiceExternalInformationSetProcedure:
			adminServiceExternalInformationSetHandler.ServeHTTP(w, r)
		case AdminServiceExternalInformationDeleteProcedure:
			adminServiceExternalInformationDeleteHandler.ServeHTTP(w, r)
		case AdminServiceKoyoCreateProcedure:
			adminServiceKoyoCreateHandler.ServeHTTP(w, r)
		case AdminServiceKoyoDeleteProcedure:
			adminServiceKoyoDeleteHandler.ServeHTTP(w, r)
		case AdminServiceKoyoAPIRevokeProcedure:
			adminServiceKoyoAPIRevokeHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedAdminServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedAdminServiceHandler struct{}

func (UnimplementedAdminServiceHandler) ClientSet(context.Context, *connect.Request[v1.ClientSetRequest]) (*connect.Response[v1.ClientSetResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.AdminService.ClientSet is not implemented"))
}

func (UnimplementedAdminServiceHandler) ClientList(context.Context, *connect.Request[v1.ClientListRequest]) (*connect.Response[v1.ClientListResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.AdminService.ClientList is not implemented"))
}

func (UnimplementedAdminServiceHandler) ClientDelete(context.Context, *connect.Request[v1.ClientDeleteRequest]) (*connect.Response[v1.ClientDeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.AdminService.ClientDelete is not implemented"))
}

func (UnimplementedAdminServiceHandler) ClientRevoke(context.Context, *connect.Request[v1.ClientRevokeRequest]) (*connect.Response[v1.ClientRevokeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.AdminService.ClientRevoke is not implemented"))
}

func (UnimplementedAdminServiceHandler) ExternalInformationSet(context.Context, *connect.Request[v1.ExternalInformationSetRequest]) (*connect.Response[v1.ExternalInformationSetResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.AdminService.ExternalInformationSet is not implemented"))
}

func (UnimplementedAdminServiceHandler) ExternalInformationDelete(context.Context, *connect.Request[v1.ExternalInformationDeleteRequest]) (*connect.Response[v1.ExternalInformationDeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.AdminService.ExternalInformationDelete is not implemented"))
}

func (UnimplementedAdminServiceHandler) KoyoCreate(context.Context, *connect.Request[v1.KoyoCreateRequest]) (*connect.Response[v1.KoyoCreateResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.AdminService.KoyoCreate is not implemented"))
}

func (UnimplementedAdminServiceHandler) KoyoDelete(context.Context, *connect.Request[v1.KoyoDeleteRequest]) (*connect.Response[v1.KoyoDeleteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.AdminService.KoyoDelete is not implemented"))
}

func (UnimplementedAdminServiceHandler) KoyoAPIRevoke(context.Context, *connect.Request[v1.KoyoAPIRevokeRequest]) (*connect.Response[v1.KoyoAPIRevokeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.AdminService.KoyoAPIRevoke is not implemented"))
}

// ProviderServiceClient is a client for the belifeline.v1.ProviderService service.
type ProviderServiceClient interface {
	// List all external information
	ExternalInformationList(context.Context, *connect.Request[v1.ExternalInformationListRequest]) (*connect.Response[v1.ExternalInformationListResponse], error)
	// List all koyo information
	KoyoList(context.Context, *connect.Request[v1.KoyoListRequest]) (*connect.ServerStreamForClient[v1.KoyoListResponse], error)
	// Get basic information about External Information
	ExternalInformationGet(context.Context, *connect.Request[v1.ExternalInformationGetRequest]) (*connect.Response[v1.ExternalInformationGetResponse], error)
	// Get koyo data generated by Koyo
	KoyoDataGet(context.Context, *connect.Request[v1.KoyoDataGetRequest]) (*connect.Response[v1.KoyoDataGetResponse], error)
}

// NewProviderServiceClient constructs a client for the belifeline.v1.ProviderService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewProviderServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ProviderServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &providerServiceClient{
		externalInformationList: connect.NewClient[v1.ExternalInformationListRequest, v1.ExternalInformationListResponse](
			httpClient,
			baseURL+ProviderServiceExternalInformationListProcedure,
			connect.WithSchema(providerServiceExternalInformationListMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		koyoList: connect.NewClient[v1.KoyoListRequest, v1.KoyoListResponse](
			httpClient,
			baseURL+ProviderServiceKoyoListProcedure,
			connect.WithSchema(providerServiceKoyoListMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		externalInformationGet: connect.NewClient[v1.ExternalInformationGetRequest, v1.ExternalInformationGetResponse](
			httpClient,
			baseURL+ProviderServiceExternalInformationGetProcedure,
			connect.WithSchema(providerServiceExternalInformationGetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		koyoDataGet: connect.NewClient[v1.KoyoDataGetRequest, v1.KoyoDataGetResponse](
			httpClient,
			baseURL+ProviderServiceKoyoDataGetProcedure,
			connect.WithSchema(providerServiceKoyoDataGetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// providerServiceClient implements ProviderServiceClient.
type providerServiceClient struct {
	externalInformationList *connect.Client[v1.ExternalInformationListRequest, v1.ExternalInformationListResponse]
	koyoList                *connect.Client[v1.KoyoListRequest, v1.KoyoListResponse]
	externalInformationGet  *connect.Client[v1.ExternalInformationGetRequest, v1.ExternalInformationGetResponse]
	koyoDataGet             *connect.Client[v1.KoyoDataGetRequest, v1.KoyoDataGetResponse]
}

// ExternalInformationList calls belifeline.v1.ProviderService.ExternalInformationList.
func (c *providerServiceClient) ExternalInformationList(ctx context.Context, req *connect.Request[v1.ExternalInformationListRequest]) (*connect.Response[v1.ExternalInformationListResponse], error) {
	return c.externalInformationList.CallUnary(ctx, req)
}

// KoyoList calls belifeline.v1.ProviderService.KoyoList.
func (c *providerServiceClient) KoyoList(ctx context.Context, req *connect.Request[v1.KoyoListRequest]) (*connect.ServerStreamForClient[v1.KoyoListResponse], error) {
	return c.koyoList.CallServerStream(ctx, req)
}

// ExternalInformationGet calls belifeline.v1.ProviderService.ExternalInformationGet.
func (c *providerServiceClient) ExternalInformationGet(ctx context.Context, req *connect.Request[v1.ExternalInformationGetRequest]) (*connect.Response[v1.ExternalInformationGetResponse], error) {
	return c.externalInformationGet.CallUnary(ctx, req)
}

// KoyoDataGet calls belifeline.v1.ProviderService.KoyoDataGet.
func (c *providerServiceClient) KoyoDataGet(ctx context.Context, req *connect.Request[v1.KoyoDataGetRequest]) (*connect.Response[v1.KoyoDataGetResponse], error) {
	return c.koyoDataGet.CallUnary(ctx, req)
}

// ProviderServiceHandler is an implementation of the belifeline.v1.ProviderService service.
type ProviderServiceHandler interface {
	// List all external information
	ExternalInformationList(context.Context, *connect.Request[v1.ExternalInformationListRequest]) (*connect.Response[v1.ExternalInformationListResponse], error)
	// List all koyo information
	KoyoList(context.Context, *connect.Request[v1.KoyoListRequest], *connect.ServerStream[v1.KoyoListResponse]) error
	// Get basic information about External Information
	ExternalInformationGet(context.Context, *connect.Request[v1.ExternalInformationGetRequest]) (*connect.Response[v1.ExternalInformationGetResponse], error)
	// Get koyo data generated by Koyo
	KoyoDataGet(context.Context, *connect.Request[v1.KoyoDataGetRequest]) (*connect.Response[v1.KoyoDataGetResponse], error)
}

// NewProviderServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewProviderServiceHandler(svc ProviderServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	providerServiceExternalInformationListHandler := connect.NewUnaryHandler(
		ProviderServiceExternalInformationListProcedure,
		svc.ExternalInformationList,
		connect.WithSchema(providerServiceExternalInformationListMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	providerServiceKoyoListHandler := connect.NewServerStreamHandler(
		ProviderServiceKoyoListProcedure,
		svc.KoyoList,
		connect.WithSchema(providerServiceKoyoListMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	providerServiceExternalInformationGetHandler := connect.NewUnaryHandler(
		ProviderServiceExternalInformationGetProcedure,
		svc.ExternalInformationGet,
		connect.WithSchema(providerServiceExternalInformationGetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	providerServiceKoyoDataGetHandler := connect.NewUnaryHandler(
		ProviderServiceKoyoDataGetProcedure,
		svc.KoyoDataGet,
		connect.WithSchema(providerServiceKoyoDataGetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/belifeline.v1.ProviderService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ProviderServiceExternalInformationListProcedure:
			providerServiceExternalInformationListHandler.ServeHTTP(w, r)
		case ProviderServiceKoyoListProcedure:
			providerServiceKoyoListHandler.ServeHTTP(w, r)
		case ProviderServiceExternalInformationGetProcedure:
			providerServiceExternalInformationGetHandler.ServeHTTP(w, r)
		case ProviderServiceKoyoDataGetProcedure:
			providerServiceKoyoDataGetHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedProviderServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedProviderServiceHandler struct{}

func (UnimplementedProviderServiceHandler) ExternalInformationList(context.Context, *connect.Request[v1.ExternalInformationListRequest]) (*connect.Response[v1.ExternalInformationListResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.ProviderService.ExternalInformationList is not implemented"))
}

func (UnimplementedProviderServiceHandler) KoyoList(context.Context, *connect.Request[v1.KoyoListRequest], *connect.ServerStream[v1.KoyoListResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.ProviderService.KoyoList is not implemented"))
}

func (UnimplementedProviderServiceHandler) ExternalInformationGet(context.Context, *connect.Request[v1.ExternalInformationGetRequest]) (*connect.Response[v1.ExternalInformationGetResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.ProviderService.ExternalInformationGet is not implemented"))
}

func (UnimplementedProviderServiceHandler) KoyoDataGet(context.Context, *connect.Request[v1.KoyoDataGetRequest]) (*connect.Response[v1.KoyoDataGetResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.ProviderService.KoyoDataGet is not implemented"))
}

// ExternalInformationServiceClient is a client for the belifeline.v1.ExternalInformationService
// service.
type ExternalInformationServiceClient interface {
	// rpc to inform kizuna that extinfo (External API and other information) has been updated
	ExternalInformationUpdateNotification(context.Context, *connect.Request[v1.ExternalInformationUpdateNotificationRequest]) (*connect.Response[v1.ExternalInformationUpdateNotificationResponse], error)
}

// NewExternalInformationServiceClient constructs a client for the
// belifeline.v1.ExternalInformationService service. By default, it uses the Connect protocol with
// the binary Protobuf Codec, asks for gzipped responses, and sends uncompressed requests. To use
// the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewExternalInformationServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ExternalInformationServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &externalInformationServiceClient{
		externalInformationUpdateNotification: connect.NewClient[v1.ExternalInformationUpdateNotificationRequest, v1.ExternalInformationUpdateNotificationResponse](
			httpClient,
			baseURL+ExternalInformationServiceExternalInformationUpdateNotificationProcedure,
			connect.WithSchema(externalInformationServiceExternalInformationUpdateNotificationMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// externalInformationServiceClient implements ExternalInformationServiceClient.
type externalInformationServiceClient struct {
	externalInformationUpdateNotification *connect.Client[v1.ExternalInformationUpdateNotificationRequest, v1.ExternalInformationUpdateNotificationResponse]
}

// ExternalInformationUpdateNotification calls
// belifeline.v1.ExternalInformationService.ExternalInformationUpdateNotification.
func (c *externalInformationServiceClient) ExternalInformationUpdateNotification(ctx context.Context, req *connect.Request[v1.ExternalInformationUpdateNotificationRequest]) (*connect.Response[v1.ExternalInformationUpdateNotificationResponse], error) {
	return c.externalInformationUpdateNotification.CallUnary(ctx, req)
}

// ExternalInformationServiceHandler is an implementation of the
// belifeline.v1.ExternalInformationService service.
type ExternalInformationServiceHandler interface {
	// rpc to inform kizuna that extinfo (External API and other information) has been updated
	ExternalInformationUpdateNotification(context.Context, *connect.Request[v1.ExternalInformationUpdateNotificationRequest]) (*connect.Response[v1.ExternalInformationUpdateNotificationResponse], error)
}

// NewExternalInformationServiceHandler builds an HTTP handler from the service implementation. It
// returns the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewExternalInformationServiceHandler(svc ExternalInformationServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	externalInformationServiceExternalInformationUpdateNotificationHandler := connect.NewUnaryHandler(
		ExternalInformationServiceExternalInformationUpdateNotificationProcedure,
		svc.ExternalInformationUpdateNotification,
		connect.WithSchema(externalInformationServiceExternalInformationUpdateNotificationMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/belifeline.v1.ExternalInformationService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ExternalInformationServiceExternalInformationUpdateNotificationProcedure:
			externalInformationServiceExternalInformationUpdateNotificationHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedExternalInformationServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedExternalInformationServiceHandler struct{}

func (UnimplementedExternalInformationServiceHandler) ExternalInformationUpdateNotification(context.Context, *connect.Request[v1.ExternalInformationUpdateNotificationRequest]) (*connect.Response[v1.ExternalInformationUpdateNotificationResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.ExternalInformationService.ExternalInformationUpdateNotification is not implemented"))
}

// KoyoServiceClient is a client for the belifeline.v1.KoyoService service.
type KoyoServiceClient interface {
	// Update koyo information
	KoyoUpdate(context.Context, *connect.Request[v1.KoyoUpdateRequest]) (*connect.Response[v1.KoyoUpdateResponse], error)
	// After koyo processes the data, it calls this rpc to store the generated data (in permanent storage via kizuna)
	KoyoDataAdd(context.Context, *connect.Request[v1.KoyoDataAddRequest]) (*connect.Response[v1.KoyoDataAddResponse], error)
}

// NewKoyoServiceClient constructs a client for the belifeline.v1.KoyoService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewKoyoServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) KoyoServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &koyoServiceClient{
		koyoUpdate: connect.NewClient[v1.KoyoUpdateRequest, v1.KoyoUpdateResponse](
			httpClient,
			baseURL+KoyoServiceKoyoUpdateProcedure,
			connect.WithSchema(koyoServiceKoyoUpdateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		koyoDataAdd: connect.NewClient[v1.KoyoDataAddRequest, v1.KoyoDataAddResponse](
			httpClient,
			baseURL+KoyoServiceKoyoDataAddProcedure,
			connect.WithSchema(koyoServiceKoyoDataAddMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// koyoServiceClient implements KoyoServiceClient.
type koyoServiceClient struct {
	koyoUpdate  *connect.Client[v1.KoyoUpdateRequest, v1.KoyoUpdateResponse]
	koyoDataAdd *connect.Client[v1.KoyoDataAddRequest, v1.KoyoDataAddResponse]
}

// KoyoUpdate calls belifeline.v1.KoyoService.KoyoUpdate.
func (c *koyoServiceClient) KoyoUpdate(ctx context.Context, req *connect.Request[v1.KoyoUpdateRequest]) (*connect.Response[v1.KoyoUpdateResponse], error) {
	return c.koyoUpdate.CallUnary(ctx, req)
}

// KoyoDataAdd calls belifeline.v1.KoyoService.KoyoDataAdd.
func (c *koyoServiceClient) KoyoDataAdd(ctx context.Context, req *connect.Request[v1.KoyoDataAddRequest]) (*connect.Response[v1.KoyoDataAddResponse], error) {
	return c.koyoDataAdd.CallUnary(ctx, req)
}

// KoyoServiceHandler is an implementation of the belifeline.v1.KoyoService service.
type KoyoServiceHandler interface {
	// Update koyo information
	KoyoUpdate(context.Context, *connect.Request[v1.KoyoUpdateRequest]) (*connect.Response[v1.KoyoUpdateResponse], error)
	// After koyo processes the data, it calls this rpc to store the generated data (in permanent storage via kizuna)
	KoyoDataAdd(context.Context, *connect.Request[v1.KoyoDataAddRequest]) (*connect.Response[v1.KoyoDataAddResponse], error)
}

// NewKoyoServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewKoyoServiceHandler(svc KoyoServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	koyoServiceKoyoUpdateHandler := connect.NewUnaryHandler(
		KoyoServiceKoyoUpdateProcedure,
		svc.KoyoUpdate,
		connect.WithSchema(koyoServiceKoyoUpdateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	koyoServiceKoyoDataAddHandler := connect.NewUnaryHandler(
		KoyoServiceKoyoDataAddProcedure,
		svc.KoyoDataAdd,
		connect.WithSchema(koyoServiceKoyoDataAddMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/belifeline.v1.KoyoService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case KoyoServiceKoyoUpdateProcedure:
			koyoServiceKoyoUpdateHandler.ServeHTTP(w, r)
		case KoyoServiceKoyoDataAddProcedure:
			koyoServiceKoyoDataAddHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedKoyoServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedKoyoServiceHandler struct{}

func (UnimplementedKoyoServiceHandler) KoyoUpdate(context.Context, *connect.Request[v1.KoyoUpdateRequest]) (*connect.Response[v1.KoyoUpdateResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.KoyoService.KoyoUpdate is not implemented"))
}

func (UnimplementedKoyoServiceHandler) KoyoDataAdd(context.Context, *connect.Request[v1.KoyoDataAddRequest]) (*connect.Response[v1.KoyoDataAddResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("belifeline.v1.KoyoService.KoyoDataAdd is not implemented"))
}
